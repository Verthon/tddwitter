import 'module';
/*#__PURE__*/ import.meta.url;
import { SDK } from "@rsdoctor/types";
import { chalk, logger } from "@rsdoctor/utils/logger";
import assert from "assert";
import { convertReportCodeTypeObject, processModeConfigurations } from "./normalize-config.js";
function defaultBoolean(v, dft) {
    return 'boolean' == typeof v ? v : dft;
}
function getDefaultOutput() {
    return {
        mode: void 0,
        reportCodeType: {
            noModuleSource: false,
            noAssetsAndModuleSource: false,
            noCode: false
        },
        options: void 0,
        reportDir: '',
        compressData: void 0
    };
}
function getDefaultSupports() {
    return {
        parseBundle: true,
        banner: void 0,
        gzip: true
    };
}
function normalizeFeatures(features, mode) {
    if (Array.isArray(features)) return {
        loader: features.includes('loader'),
        plugins: features.includes('plugins'),
        resolver: features.includes('resolver'),
        bundle: features.includes('bundle'),
        treeShaking: features.includes('treeShaking'),
        lite: features.includes('lite') || mode === SDK.IMode[SDK.IMode.lite]
    };
    return {
        loader: defaultBoolean(features.loader, true),
        plugins: defaultBoolean(features.plugins, true),
        resolver: defaultBoolean(features.resolver, false),
        bundle: defaultBoolean(features.bundle, true),
        treeShaking: defaultBoolean(features.treeShaking, false),
        lite: defaultBoolean(features.lite, false) || mode === SDK.IMode[SDK.IMode.lite]
    };
}
function normalizeLinter(linter) {
    return {
        rules: {},
        extends: [],
        level: 'Error',
        ...linter
    };
}
function isValidMode(mode) {
    return 'string' == typeof mode && [
        'brief',
        'normal',
        'lite'
    ].includes(mode);
}
function normalizeUserConfig(config = {}) {
    const { linter = {}, features = {}, loaderInterceptorOptions = {}, disableClientServer = false, sdkInstance, innerClientPath = '', output = getDefaultOutput(), supports = getDefaultSupports(), port, printLog = {
        serverUrls: true
    }, mode, brief } = config;
    assert('object' == typeof linter);
    assert('object' == typeof features || Array.isArray(features));
    assert('object' == typeof loaderInterceptorOptions);
    assert('boolean' == typeof disableClientServer);
    let finalMode = ('mode' in output && isValidMode(output.mode) ? 'lite' === output.mode ? SDK.IMode[SDK.IMode.normal] : output.mode : void 0) || mode || SDK.IMode[SDK.IMode.normal];
    if (mode) logger.info(chalk.yellow("The 'mode' configuration will be deprecated in a future version. Please use 'output.mode' instead."));
    const _features = normalizeFeatures(features, finalMode);
    const _linter = normalizeLinter(linter);
    if (_features.lite || finalMode === SDK.IMode[SDK.IMode.lite]) logger.info(chalk.yellow("Lite features will be deprecated in a future version. Please use 'output: { reportCodeType: { noAssetsAndModuleSource: true }}' instead."));
    const { finalBrief, finalNormalOptions } = processModeConfigurations(finalMode, output, brief);
    if (_features.lite && finalMode !== SDK.IMode[SDK.IMode.brief]) finalMode = SDK.IMode[SDK.IMode.lite];
    const reportCodeType = output.reportCodeType ? normalizeReportType(output.reportCodeType, finalMode) : normalizeReportType(getDefaultOutput().reportCodeType, finalMode);
    const res = {
        linter: _linter,
        features: _features,
        loaderInterceptorOptions: {
            skipLoaders: Array.isArray(loaderInterceptorOptions.skipLoaders) ? loaderInterceptorOptions.skipLoaders : []
        },
        disableClientServer,
        sdkInstance,
        output: {
            mode: finalMode,
            options: 'brief' === finalMode ? finalBrief : finalNormalOptions,
            reportCodeType,
            reportDir: output.reportDir || ''
        },
        innerClientPath,
        supports,
        port,
        printLog
    };
    if (void 0 !== output.compressData) logger.info(chalk.yellow("The 'compressData' configuration will be deprecated in a future version."));
    return res;
}
const normalizeReportType = (reportCodeType, mode)=>{
    const convertedReportCodeType = 'object' == typeof reportCodeType ? convertReportCodeTypeObject(reportCodeType) : reportCodeType;
    if ('noCode' === convertedReportCodeType) return SDK.ToDataType.NoCode;
    if (mode === SDK.IMode[SDK.IMode.brief]) return SDK.ToDataType.NoCode;
    if (mode === SDK.IMode[SDK.IMode.lite]) return SDK.ToDataType.NoSourceAndAssets;
    if ('noAssetsAndModuleSource' === convertedReportCodeType) return SDK.ToDataType.NoSourceAndAssets;
    if ('noModuleSource' === convertedReportCodeType) return SDK.ToDataType.NoSource;
    return SDK.ToDataType.Normal;
};
function normalizeRspackUserOptions(options) {
    var _options_experiments, _options_experiments1;
    const config = normalizeUserConfig(options);
    config.experiments ??= {
        enableNativePlugin: {
            moduleGraph: false,
            chunkGraph: false
        }
    };
    if ('boolean' == typeof (null == (_options_experiments = options.experiments) ? void 0 : _options_experiments.enableNativePlugin) && (null == (_options_experiments1 = options.experiments) ? void 0 : _options_experiments1.enableNativePlugin) === true) config.experiments.enableNativePlugin = {
        moduleGraph: true,
        chunkGraph: true
    };
    else config.experiments.enableNativePlugin = {
        moduleGraph: false,
        chunkGraph: false
    };
    return config;
}
export { normalizeReportType, normalizeRspackUserOptions, normalizeUserConfig };
