let globalController;
import { Loader } from "@rsdoctor/core/build-utils";
import { InternalBundlePlugin, InternalBundleTagPlugin, InternalErrorReporterPlugin, InternalLoaderPlugin, InternalPluginsPlugin, InternalRulesPlugin, InternalSummaryPlugin, ensureModulesChunksGraphFn, handleBriefModeReport, normalizeRspackUserOptions, normalizeUserConfig, processCompilerConfig, setSDK } from "@rsdoctor/core/plugins";
import { RsdoctorSDK, RsdoctorSDKController, findRoot } from "@rsdoctor/sdk";
import { Constants, Manifest, SDK } from "@rsdoctor/types";
import path from "path";
import { ModuleGraph } from "@rsdoctor/graph";
import { Loader as common_Loader } from "@rsdoctor/utils/common";
import { chalk, logger, time, timeEnd } from "@rsdoctor/utils/logger";
var __webpack_modules__ = {
    "./package.json": function(module) {
        module.exports = JSON.parse('{"name":"@rsdoctor/rspack-plugin","version":"1.3.1","repository":{"type":"git","url":"https://github.com/web-infra-dev/rsdoctor","directory":"packages/rspack-plugin"},"license":"MIT","main":"dist/index.cjs","types":"dist/index.d.ts","files":["dist"],"exports":{".":{"types":"./dist/index.d.ts","import":"./dist/index.js","default":"./dist/index.cjs"}},"type":"module","scripts":{"dev":"npm run start","start":"rslib build -w","build":"rslib build","test":"rstest run"},"dependencies":{"@rsdoctor/core":"workspace:*","@rsdoctor/graph":"workspace:*","@rsdoctor/sdk":"workspace:*","@rsdoctor/types":"workspace:*","@rsdoctor/utils":"workspace:*","lodash-es":"^4.17.21"},"devDependencies":{"@rspack/core":"1.5.2","@types/lodash-es":"^4.17.12","@types/node":"^22.8.1","@types/tapable":"2.2.7","tslib":"2.8.1","typescript":"^5.9.2"},"peerDependencies":{"@rspack/core":"*"},"peerDependenciesMeta":{"@rspack/core":{"optional":true}},"publishConfig":{"access":"public","registry":"https://registry.npmjs.org/"}}');
    }
}, __webpack_module_cache__ = {};
let pluginTapName = 'RsdoctorRspackPlugin', pluginTapPostOptions = {
    name: pluginTapName,
    stage: 999
};
!function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    return __webpack_modules__[moduleId](module, module.exports, __webpack_require__), module.exports;
}("./package.json");
class RsdoctorRspackPlugin {
    name = pluginTapName;
    sdk;
    isRsdoctorPlugin;
    _bootstrapTask;
    browserIsOpened = !1;
    modulesGraph;
    options;
    outsideInstance;
    constructor(options){
        this.options = normalizeRspackUserOptions(Object.assign(options || {}, {
            supports: {
                ...options?.supports
            }
        }));
        let { port, output, innerClientPath, printLog, sdkInstance } = this.options;
        this.sdk = this.options.sdkInstance ?? new RsdoctorSDK({
            port,
            name: pluginTapName,
            root: process.cwd(),
            type: output.reportCodeType,
            config: {
                innerClientPath,
                printLog,
                mode: output.mode ? output.mode : void 0,
                brief: output.mode === SDK.IMode[SDK.IMode.brief] && output.options || void 0
            }
        }), this.outsideInstance = !!sdkInstance, this.modulesGraph = new ModuleGraph(), this.isRsdoctorPlugin = !0;
    }
    apply(compiler) {
        time('RsdoctorRspackPlugin.apply');
        try {
            this._bootstrapTask || (this._bootstrapTask = this.sdk.bootstrap()), compiler.options.name && this.sdk.setName(compiler.options.name), setSDK(this.sdk), compiler.hooks.afterPlugins.tap(pluginTapPostOptions, this.afterPlugins.bind(this, compiler)), compiler.hooks.done.tapPromise({
                ...pluginTapPostOptions,
                stage: pluginTapPostOptions.stage + 100
            }, this.done.bind(this, compiler)), new InternalSummaryPlugin(this).apply(compiler), this.options.features.loader && (new Loader.ProbeLoaderPlugin().apply(compiler), this.sdk.addClientRoutes([
                Manifest.RsdoctorManifestClientRoutes.WebpackLoaders
            ]), common_Loader.isVue(compiler) || new InternalLoaderPlugin(this).apply(compiler)), this.options.features.plugins && new InternalPluginsPlugin(this).apply(compiler), this.options.features.bundle && (new InternalBundlePlugin(this).apply(compiler), new InternalBundleTagPlugin(this).apply(compiler)), this.options.features.resolver && logger.info(chalk.yellow('Rspack currently does not support Resolver capabilities.')), new InternalRulesPlugin(this).apply(compiler), new InternalErrorReporterPlugin(this).apply(compiler);
            let RsdoctorRspackNativePlugin = compiler.webpack.experiments?.RsdoctorPlugin;
            if (RsdoctorRspackNativePlugin) {
                logger.debug('[RspackNativePlugin] Enabled');
                let enableNativePlugin = this.options.experiments?.enableNativePlugin;
                new RsdoctorRspackNativePlugin({
                    moduleGraphFeatures: 'boolean' == typeof enableNativePlugin ? enableNativePlugin : enableNativePlugin?.moduleGraph || !1,
                    chunkGraphFeatures: 'boolean' == typeof enableNativePlugin ? enableNativePlugin : enableNativePlugin?.chunkGraph || !1,
                    sourceMapFeatures: {
                        cheap: !1,
                        module: !1
                    }
                }).apply(compiler);
            }
        } finally{
            timeEnd('RsdoctorRspackPlugin.apply');
        }
    }
    ensureModulesChunksGraphApplied(compiler) {
        ensureModulesChunksGraphFn(compiler, this);
    }
    afterPlugins = (compiler)=>{
        time('RsdoctorRspackPlugin.afterPlugins');
        try {
            this.getRspackConfig(compiler);
        } finally{
            timeEnd('RsdoctorRspackPlugin.afterPlugins');
        }
    };
    done = async (compiler)=>{
        time('RsdoctorRspackPlugin.done');
        try {
            await this.sdk.bootstrap(), this.sdk.addClientRoutes([
                Manifest.RsdoctorManifestClientRoutes.Overall
            ]), this.outsideInstance && 'parent' in this.sdk && this.sdk.parent.master.setOutputDir(path.resolve(this.options.output.reportDir || compiler.outputPath, `./${Constants.RsdoctorOutputFolder}`)), this.sdk.setOutputDir(path.resolve(this.options.output.reportDir || compiler.outputPath, `./${Constants.RsdoctorOutputFolder}`)), await this.sdk.writeStore(), this.options.disableClientServer || (this.options.output.mode === SDK.IMode[SDK.IMode.brief] ? handleBriefModeReport(this.sdk, this.options, this.options.disableClientServer) : await this.sdk.server.openClientPage('homepage')), this.options.disableClientServer && await this.sdk.dispose();
        } finally{
            timeEnd('RsdoctorRspackPlugin.done');
        }
    };
    getRspackConfig(compiler) {
        time('RsdoctorRspackPlugin.getRspackConfig');
        try {
            if (compiler.isChild()) return;
            let configuration = processCompilerConfig(compiler.options), rspackVersion = compiler.webpack?.rspackVersion, webpackVersion = compiler.webpack?.version;
            this.sdk.reportConfiguration({
                name: rspackVersion ? 'rspack' : 'webpack',
                version: rspackVersion || webpackVersion || 'unknown',
                config: configuration,
                root: findRoot() || ''
            });
        } finally{
            timeEnd('RsdoctorRspackPlugin.getRspackConfig');
        }
    }
}
class RsdoctorRspackMultiplePlugin extends RsdoctorRspackPlugin {
    controller;
    constructor(options = {}){
        let controller = (()=>{
            if (globalController) return globalController;
            let controller = new RsdoctorSDKController();
            return globalController = controller, controller;
        })(), normallizedOptions = normalizeUserConfig(options);
        super({
            ...options,
            sdkInstance: controller.createSlave({
                name: options.name || 'Builder',
                stage: options.stage,
                extraConfig: {
                    innerClientPath: normallizedOptions.innerClientPath,
                    printLog: normallizedOptions.printLog,
                    mode: normallizedOptions.output.mode ? normallizedOptions.output.mode : void 0,
                    brief: normallizedOptions.output.mode === SDK.IMode[SDK.IMode.brief] && normallizedOptions.output.options || void 0
                },
                type: normallizedOptions.output.reportCodeType
            })
        }), this.controller = controller;
    }
    apply(compiler) {
        'dependencies' in compiler.options && (this.sdk.dependencies = compiler.options.dependencies), super.apply(compiler);
    }
}
export { RsdoctorRspackMultiplePlugin, RsdoctorRspackPlugin };
